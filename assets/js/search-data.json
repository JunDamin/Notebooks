{
  
    
        "post0": {
            "title": "JAX를 써봅시다",
            "content": "설치를 할 때 먼저 jaxlib을 설치하고 그 버전에 맞는 jax를 설치합니다. . ! pip install jaxlib ! pip install jax==0.3.15 . from jax import numpy as jnp from jax import grad import numpy as np from plotnine import * import pandas as pd from tqdm.notebook import tqdm . 간단한 모형을 만들어 봅니다. X와 y가 2차함수 형태로 결합된 경우를 생각해 봅니다. . n = 100 X = np.random.uniform(0, 3, size=n) y = 3 * np.power(X, 2) + np.random.normal(10, 3, size=n) data = pd.DataFrame(zip(X, y), columns=[&quot;X&quot;, &quot;y&quot;]) ( ggplot(data) + aes(&quot;X&quot;, &quot;y&quot;) + geom_point() ) . &lt;ggplot: (8775257149410)&gt; . 선형 모델을 먼저 생각해 봅니다. . w = {&quot;a&quot;: 0., &quot;b&quot;: 0.} # set model def model(w, X): return w[&quot;a&quot;] * X + w[&quot;b&quot;] # set loss def loss(w, model, X, y): return jnp.power(model(w, X) - y, 2).sum() # grad loss dloss = grad(loss) . 이제 경사하강법을 활용하여 w를 찾아봅니다. . 경사하강법은 말그대로 경사를 구해서 낮은 쪽으로 이동하게 하는 것입니다. . 기본적인 아이디어는 예측치와 관측값의 차이를 합치는 손실함수(loss function)을 구합니다. 그리고 파라미터를 손실이 줄어드는 방향(경사, 미분해서 보통 구합니다)으로 조금씩 옮겨가면서 최적의 값을 찾아 한발 한발 나아가는 방식입니다. . 수식으로 간단하게 표기해보자면 $$L( theta) = sum_i ( f(x_i; theta) - y)^2$$ 로 정의하고 이 $L$을 $ theta$로 미분해 해당 미분값(경사)를 이용해서 낮추는 방향으로 파라미터 $ theta$를 바꿔가면서 찾아가는 방식입니다. . rate = 0.0001 losses = [] ws = [] for i in tqdm(range(2000)): l = loss(w, model, X, y) ws.append(w.copy()) losses.append(l) if i % 100 == 0: print(i, &quot;loss: &quot;, l) dw = dloss(w, model, X, y) for key in w.keys(): w[key] -= dw[key]*rate . 0 loss: 41606.637 100 loss: 1581.1091 200 loss: 1558.6885 300 loss: 1549.7168 400 loss: 1546.124 500 loss: 1544.6855 600 loss: 1544.1096 700 loss: 1543.8787 800 loss: 1543.7864 900 loss: 1543.7493 1000 loss: 1543.7345 1100 loss: 1543.7285 1200 loss: 1543.7263 1300 loss: 1543.7252 1400 loss: 1543.7249 1500 loss: 1543.7247 1600 loss: 1543.7246 1700 loss: 1543.7246 1800 loss: 1543.7246 1900 loss: 1543.7246 . result_df = pd.DataFrame(zip(X, np.array(model(w, X))), columns=[&quot;X&quot;, &quot;f&quot;]) ( ggplot(data=data) + aes(&quot;X&quot;, &quot;y&quot;) + geom_point() + geom_smooth(method=&quot;lm&quot;) + geom_line(data=result_df, mapping=aes(&quot;X&quot;, &quot;f&quot;), color=&quot;#ff1234&quot;) ) . &lt;ggplot: (8775132047089)&gt; . def plot(w):# overlay plots result_df = pd.DataFrame(zip(X, np.array(model(w, X))), columns=[&quot;X&quot;, &quot;f&quot;]) p = ( ggplot(data=data) + aes(&quot;X&quot;, &quot;y&quot;) + geom_point() + geom_smooth(method=&quot;lm&quot;) + geom_line(data=result_df, mapping=aes(&quot;X&quot;, &quot;f&quot;), color=&quot;#ff1234&quot;) ) return p . plot(ws[10]) . &lt;ggplot: (8775127376119)&gt; . dfs = [pd.DataFrame(zip(map(int, np.ones_like(X)*i), X, np.array(model(ws[i], X))), columns=[&quot;i&quot;, &quot;X&quot;, &quot;f&quot;]) for i in range(0, 100, 10)] df = pd.concat(dfs) . 처음에는 많이 차이나지만 점점 해석적으로 계산한 선형 회귀 값과 유사해지는 것을 볼 수 있습니다. . 이 경사하강법의 장점은 손실함수를 정의 할 수만 있다면 적용할 수 있어 유연하게 많은 곳에 적용할 수 있습니다. . p = ( ggplot(data=df) + aes(x=&quot;X&quot;, y=&quot;f&quot;) + geom_point(data=data, mapping=aes(&quot;X&quot;, &quot;y&quot;)) + geom_smooth(data=data, method=&quot;lm&quot;, mapping=aes(&quot;X&quot;, &quot;y&quot;), color=&quot;yellow&quot;) + geom_line(color=&quot;red&quot;, size=1) + facet_wrap(&quot;i&quot;) ) p . &lt;ggplot: (8775126430660)&gt; .",
            "url": "https://jundamin.github.io/Notebooks/2022/08/30/jax%EB%A1%9C-regression%EC%9D%84-%EA%B5%AC%ED%95%B4%EB%B4%85%EC%8B%9C%EB%8B%A4.html",
            "relUrl": "/2022/08/30/jax%EB%A1%9C-regression%EC%9D%84-%EA%B5%AC%ED%95%B4%EB%B4%85%EC%8B%9C%EB%8B%A4.html",
            "date": " • Aug 30, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Julia로 행성의 겉보기 역행운동을 그려보자",
            "content": "&#50669;&#54665;&#50868;&#46041;&#51060;&#46976; ? . 유튜브를 보는 도중에 행성의 겉보기 역행 운동에 대한 영상을 보았다. 행성의 역행운동이란 지구에서 보기에 행성이 반대방향으로 움직이는 것처럼 보이는 현상이다. 행성은 태양을 중심으로 돌고 있지만, 행성 간의 공전 속도의 차이로 뒤로 움직이는 듯이 보이는 현상을 말한다. . . 행성이 있고 보이는 각이 어떻게 바뀌는지를 시뮬레이션을 해보고자 하는데 줄리아에서 애니메이션을 만들 때 사용할 수 있는 Javis를 사용해서 그려보기로 한다. . &#49324;&#51204;&#51456;&#48708; . 줄리아를 설치했다고 가정한다. . 우선 패키지를 설치해야 하는데 줄리아 REPL에서 ]으로 패키지 매니저 모드로 들어간 후 add Javis를 입력하여 처리하거나 . 아래와 같이 Pkg 모듈을 불러와서 설치해야 한다. (몇 분 정도 소요 될 수 있다.) . using Pkg Pkg.add(&quot;Javis&quot;) . 패키지를 설치했으면 그다음은 패키지를 불러와야 한다. . using Javis . &#50669;&#54665;&#50868;&#46041;&#51012; &#44396;&#54616;&#44592; &#50948;&#54620; &#54632;&#49688; . 애니메이션을 만들기 위해서 아래와 같이 함수를 정의했다. . ground : 배경을 설정하는 함수이다. | object : 25 픽셀 정도 되는 원을 그리는 함수다. | path! : 경로에 점을 찍어두는 함수다. | connector : 두 점을 지나는 선을 긋는 하수다. | extender : 안쪽 행성에서 바깥쪽 행성이 어디에 보여지를 그리는 함수다. | abs : 두 Point간의 거리를 구하는 함수이다. | getpoint : 특정 지점을 지나는 백터가 원과 접하는 점을 구하는 함수다. | . function ground(args...) background(&quot;white&quot;) # canvas background sethue(&quot;black&quot;) # pen color end function object(p=O, color=&quot;black&quot;) sethue(color) circle(p, 25, :fill) return p end function path!(points, pos, color) sethue(color) push!(points, pos) # add pos to points circle.(points, 2, :fill) # draws a circle for each point using broadcasting end function connector(p1, p2, color) sethue(color) line(p1,p2, :stroke) end function extender(points, p1, p2, r, color) sethue(color) d = p2 - p1 p3 = getpoint(p2, d, r, O) line(p1, p3, :stroke) circle(p3, 2, :fill) push!(points, p3) if length(points) &gt; 200 popat!(points, 1) end circle.(points, 2, :fill) end import Base.abs function abs(p::Point, p0::Point) d = p - p0 r = sqrt(d.x^2 + d.y^2) return r end function getpoint(p, d, r, p0) λ = 0.001 rate = 0.001 new_p = p while true new_p = p + λ * d if r &lt; abs(new_p, p0) break end λ += rate end return new_p end . getpoint (generic function with 1 method) . &#44536;&#47548;&#51012; &#44536;&#47536;&#45796; . 우선 캔버스를 그린 후 붉은 행성과 파란 행성이 돌고 있다고 가정한다. . n = 1000 myvideo = Video(2000, 2000) Background(1:n, ground) path_of_red = Point[] path_of_blue = Point[] red_ball = Object(1:n, (args...)-&gt;object(O, &quot;#ff2211&quot;), Point(100,0)) act!(red_ball, Action(anim_rotate_around(24π, O))) blue_ball = Object(1:n, (args...)-&gt;object(O, &quot;#1122ff&quot;), Point(200,0)) act!(blue_ball, Action(anim_rotate_around(7π, O))) Object(1:n, (args...)-&gt;connector(pos(red_ball), pos(blue_ball), &quot;black&quot;)) Object(1:n, (args...)-&gt;path!(path_of_red, pos(red_ball), &quot;red&quot;)) Object(1:n, (args...)-&gt;path!(path_of_blue, pos(blue_ball), &quot;blue&quot;)) points = [] Object(1:n, (args...)-&gt;extender(points, pos(red_ball), pos(blue_ball), 800, &quot;#112233&quot;)) render( myvideo; pathname=&quot;ghtop_images/retrograde_motion.gif&quot; ) . Rendering frames...100%|████████████████████████████████| Time: 0:02:19 . &#34;ghtop_images/retrograde_motion.gif&#34; . 그림을 그려보면 아래와 같이 결과가 나온다. . 보면 알 수 있듯이 내행성이 외행성을 빠르게 통과할 때 행성이 뒤로 가는 것처럼 보이게 된다. . .",
            "url": "https://jundamin.github.io/Notebooks/2022/02/02/%EC%97%AD%ED%96%89%EC%9A%B4%EB%8F%99.html",
            "relUrl": "/2022/02/02/%EC%97%AD%ED%96%89%EC%9A%B4%EB%8F%99.html",
            "date": " • Feb 2, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "오프라인에서 패키지 설치하기",
            "content": "인터넷이 연될되지 않은 상황에서 파이썬 패키지를 설치하고자 할 때 알아두어야 할 것을 정리해 보고자 한다. . 패키지를 받는다. pypi에서 whl 하나를 받을 순 있긴 한데 관련된 패키지가 없으면 결국 작동이 안된다. | pip download 형식으로 작성하면 된다. | 단 운영하고자 하는 OS에서 가동이 가능한 파일을 받아야 한다. | . | 패키지 파일을 옮긴다. 패키지 파일을 설치하고자 하는 컴퓨터로 옮겨야 한다. | 이 부분은 망분리 방식에 따라 다르기 때문에 별도로 다루진 않는다. | . | pip에서 링크 옵션을 지정해서 할 수 있다. --no-index옵션과 --find-links옵션을 쓰면 설치할 수 있다. | . | 패키지 중에서 API wrapper형식으로 된 경우 해당 소프트웨어를 설치해야 한다. altair를 쓰고자 하면 vega를 설치해야 한다. | . | 예시 . pip install --no-index --find-links {패키지가 있는 경로} {설치할 패키지} .",
            "url": "https://jundamin.github.io/Notebooks/2021/12/23/%EC%98%A4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9C%BC%EB%A1%9C-%ED%8C%A8%ED%82%A4%EC%A7%80-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0.html",
            "relUrl": "/2021/12/23/%EC%98%A4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9C%BC%EB%A1%9C-%ED%8C%A8%ED%82%A4%EC%A7%80-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0.html",
            "date": " • Dec 23, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Pycaret 사용해 보기",
            "content": "pycaret? . Pycaret은 로우코드 머신러닝 라이브러리라고 합니다. . sk-learn과 같은 머신러닝 패키지와의 가장 큰 차이점은 타깃을 하고 있는 부분이 모델이 아니라 머신러닝 프로세스라는 점입니다. . 보통 머신러닝 라이브러리는 새로운 알고리즘이나 방식을 쉽게 적용할 수 있게 만듭니다. sk-learn을 보시면 쉽게 이해할 수 있겠지만, 모델을 정의하고 데이터를 넣고 모델의 성능을 확인할 수 있습니다. . 하지만 보통 우리가 하고자 하는 것은 특정 모델을 만드는 것이 아니라 모델의 성능을 비교하고 적용하는 것입니다. . Pycaret은 바로 이 부분, 모델을 비교하고 그것을 배포하는 것을 자동화 하는 라이브러리라고 보시면 됩니다. .",
            "url": "https://jundamin.github.io/Notebooks/2021/12/08/pycaret.html",
            "relUrl": "/2021/12/08/pycaret.html",
            "date": " • Dec 8, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Fastpages로 블로그 시작하기",
            "content": "&#49884;&#51089;&#54616;&#44172; &#46108; &#51060;&#50976; . Jupyter notebook으로 글을 쓰곤 하는데 이를 가공하지 않고 올릴 수 있는 곳을 찾고 있었다. . 그러다가 Fastpages를 알게 되어 시작하고자 한다. . &#49444;&#52824;&#54616;&#44592; . 아직 초보라서 그렇겠지만, 기존 가이드를 기반으로 하려고 한다. . &#47112;&#54252;&#51648;&#53664;&#47532; &#49373;&#49457;&#54616;&#44592; . &#53412; &#49373;&#49457;&#54616;&#44592; . 주의할 점은 merge하기 전에 키 설정을 해야 한다. 안 그러면 에러가 나더라. . SSH_DEPLOY_KEY라는 이름은 필수다. . &#51060;&#51228; &#54168;&#51060;&#51648; &#48320;&#44221;&#54616;&#44592; . 로고는 index.html 제목이란 footer에서 써있는 건 _config.yml . 아티클이랑은 _notebooks, _posts(md), _word에 yyyy-mm-dd_파일명. 형식으로 해야한다. . &#44544;&#50424; &#46412; &#52280;&#44256;&#54624; &#47564;&#54620; &#47928;&#48277; . 기본적으로는 Markdown문법을 따르는데 추가적으로 참고할 만한 것들이 있어 정리해 보고자 한다. . 여기서 참고20 했습니다. . 여기서 참고20 했습니다. . . 처럼 된다. .",
            "url": "https://jundamin.github.io/Notebooks/2021/12/07/fastpages.html",
            "relUrl": "/2021/12/07/fastpages.html",
            "date": " • Dec 7, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "이 블로그는 fastpages 1로 만들어졌습니다. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://jundamin.github.io/Notebooks/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jundamin.github.io/Notebooks/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}