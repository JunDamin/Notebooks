{
  
    
        "post0": {
            "title": "Julia로 행성의 겉보기 역행운동을 그려보자",
            "content": "&#49324;&#51204;&#51456;&#48708; . 줄리아를 설치했다고 가정한다. . 우선 패키지를 설치해야 하는데 줄리아 REPL에서 ]으로 패키지 매니저 모드로 들어간 후 add Javis를 입력하여 처리하거나 . 아래와 같이 Pkg 모듈을 불러와서 설치해야 한다. (몇 분 정도 소요 될 수 있다.) . using Pkg Pkg.add(&quot;Javis&quot;) . 패키지를 설치했으면 그다음은 패키지를 불러와야 한다. . using Javis . &#50669;&#54665;&#50868;&#46041;&#51012; &#44396;&#54616;&#44592; &#50948;&#54620; &#54632;&#49688; . 애니메이션을 만들기 위해서 아래와 같이 함수를 정의했다. . ground : 배경을 설정하는 함수이다. | object : 25 픽셀 정도 되는 원을 그리는 함수다. | path! : 경로에 점을 찍어두는 함수다. | connector : 두 점을 지나는 선을 긋는 하수다. | extender : 안쪽 행성에서 바깥쪽 행성이 어디에 보여지를 그리는 함수다. | abs : 두 Point간의 거리를 구하는 함수이다. | getpoint : 특정 지점을 지나는 백터가 원과 접하는 점을 구하는 함수다. | . function ground(args...) background(&quot;white&quot;) # canvas background sethue(&quot;black&quot;) # pen color end function object(p=O, color=&quot;black&quot;) sethue(color) circle(p, 25, :fill) return p end function path!(points, pos, color) sethue(color) push!(points, pos) # add pos to points circle.(points, 2, :fill) # draws a circle for each point using broadcasting end function connector(p1, p2, color) sethue(color) line(p1,p2, :stroke) end function extender(points, p1, p2, r, color) sethue(color) d = p2 - p1 p3 = getpoint(p2, d, r, O) line(p1, p3, :stroke) circle(p3, 2, :fill) push!(points, p3) if length(points) &gt; 200 popat!(points, 1) end circle.(points, 2, :fill) end import Base.abs function abs(p::Point, p0::Point) d = p - p0 r = sqrt(d.x^2 + d.y^2) return r end function getpoint(p, d, r, p0) λ = 0.001 rate = 0.001 new_p = p while true new_p = p + λ * d if r &lt; abs(new_p, p0) break end λ += rate end return new_p end . getpoint (generic function with 1 method) . &#44536;&#47548;&#51012; &#44536;&#47536;&#45796; . 우선 캔버스를 그린 후 붉은 행성과 파란 행성이 돌고 있다고 가정한다. . n = 1000 myvideo = Video(2000, 2000) Background(1:n, ground) path_of_red = Point[] path_of_blue = Point[] red_ball = Object(1:n, (args...)-&gt;object(O, &quot;#ff2211&quot;), Point(100,0)) act!(red_ball, Action(anim_rotate_around(24π, O))) blue_ball = Object(1:n, (args...)-&gt;object(O, &quot;#1122ff&quot;), Point(200,0)) act!(blue_ball, Action(anim_rotate_around(7π, O))) Object(1:n, (args...)-&gt;connector(pos(red_ball), pos(blue_ball), &quot;black&quot;)) Object(1:n, (args...)-&gt;path!(path_of_red, pos(red_ball), &quot;red&quot;)) Object(1:n, (args...)-&gt;path!(path_of_blue, pos(blue_ball), &quot;blue&quot;)) points = [] Object(1:n, (args...)-&gt;extender(points, pos(red_ball), pos(blue_ball), 800, &quot;#112233&quot;)) render( myvideo; pathname=&quot;ghtop_images/retrograde_motion.gif&quot; ) . Rendering frames...100%|████████████████████████████████| Time: 0:02:19 . &#34;ghtop_images/retrograde_motion.gif&#34; . 그림을 그려보면 아래와 같이 결과가 나온다. . 보면 알 수 있듯이 내행성이 외행성을 빠르게 통과할 때 행성이 뒤로 가는 것처럼 보이게 된다. . .",
            "url": "https://jundamin.github.io/Notebooks/2022/02/02/%EC%97%AD%ED%96%89%EC%9A%B4%EB%8F%99.html",
            "relUrl": "/2022/02/02/%EC%97%AD%ED%96%89%EC%9A%B4%EB%8F%99.html",
            "date": " • Feb 2, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "오프라인에서 패키지 설치하기",
            "content": "",
            "url": "https://jundamin.github.io/Notebooks/2021/12/23/%EC%98%A4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9C%BC%EB%A1%9C-%ED%8C%A8%ED%82%A4%EC%A7%80-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0.html",
            "relUrl": "/2021/12/23/%EC%98%A4%ED%94%84%EB%9D%BC%EC%9D%B8%EC%9C%BC%EB%A1%9C-%ED%8C%A8%ED%82%A4%EC%A7%80-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0.html",
            "date": " • Dec 23, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Pycaret 사용해 보기",
            "content": "pycaret? . Pycaret은 로우코드 머신러닝 라이브러리라고 합니다. . sk-learn과 같은 머신러닝 패키지와의 가장 큰 차이점은 타깃을 하고 있는 부분이 모델이 아니라 머신러닝 프로세스라는 점입니다. . 보통 머신러닝 라이브러리는 새로운 알고리즘이나 방식을 쉽게 적용할 수 있게 만듭니다. sk-learn을 보시면 쉽게 이해할 수 있겠지만, 모델을 정의하고 데이터를 넣고 모델의 성능을 확인할 수 있습니다. . 하지만 보통 우리가 하고자 하는 것은 특정 모델을 만드는 것이 아니라 모델의 성능을 비교하고 적용하는 것입니다. . Pycaret은 바로 이 부분, 모델을 비교하고 그것을 배포하는 것을 자동화 하는 라이브러리라고 보시면 됩니다. .",
            "url": "https://jundamin.github.io/Notebooks/2021/12/08/pycaret.html",
            "relUrl": "/2021/12/08/pycaret.html",
            "date": " • Dec 8, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Fastpages로 블로그 시작하기",
            "content": "",
            "url": "https://jundamin.github.io/Notebooks/2021/12/07/fastpages.html",
            "relUrl": "/2021/12/07/fastpages.html",
            "date": " • Dec 7, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "이 블로그는 fastpages 1로 만들어졌습니다. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://jundamin.github.io/Notebooks/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jundamin.github.io/Notebooks/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}